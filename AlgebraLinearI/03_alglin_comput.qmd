---
title: "Computa√ß√µes com Python III"
number-sections: true
lang: pt-BR
--- 

## O espa√ßo de fun√ß√µes anal√≠ticas

Sejam $a,b\in\R$ com $a<b$ e considere e espa√ßo vetorial $C^\infty[a,b]$ de fun√ß√µes anal√≠ticas no intervalo $[a,b]$. O espa√ßo $C^\infty[a,b]$  √© espa√ßo com produto interno onde o produto interno para $f,g\in C^\infty[a,b]$ √© definido como 
$$
\left<f,g\right>=\int_a^b fg\, dx.
$${#eq-prod-int-int}
Hoje, n√≥s vamos fazer algumas computa√ß√µes no espa√ßo $C^\infty[a,b]$.


:::{#exm-ip-int}
Ponha, por exemplo, $a=-1$, $b=1$. Vamos verificar que as fun√ß√µes $f(x)=x$ e $g(x)=x^2$ s√£o ortogonais. 
```python
from sympy import integrate, var, cos, sin, pi, Integral, plot
x = var('x')
f, g = x, x**2
integrate( f*g, (x,-1,1))
0
```
:::
Observe como a fun√ß√£o [`integrate`](https://docs.sympy.org/latest/modules/integrals/integrals.html) est√° usada para calcular a integral.

:::{#exr-ip-int1}
Escreva uma fun√ß√£o `inner_product(f, g, var, a, b)` que devolve o produto interno das fun√ß√µes $f$ e $g$ sobre o intervalo $[a,b]$. A sua fun√ß√£o deve verificar os seguintes valores.
```python
inner_product( x, x**2, x, -1, 1 )
0
inner_product( 1, x**2, x, -1, 1 )
2/3
inner_product( cos(x), sin(x), x, -pi, pi )
0
inner_product( cos(x), cos(x), x, -pi, pi )
ùúã
```
:::

:::{#exr-proj-ort}
Escreva uma fun√ß√£o `orthogonal_projection(f, g, var, a, b)` para calcular a proje√ß√£o ortogonal de $f$ sobre $g$ (@prp-proj-ort) considerando o 
produto interno na @eq-prod-int-int. Use a fun√ß√£o `inner_product` que escreveu no @exr-ip-int1. A sua implementa√ß√£o deve verificar as seguintes computa√ß√µes. 
```python
orthogonal_projection( x, x**2, x, -1, 1 )
0
orthogonal_projection( 1, x**2, x, -1, 1 )
5x^2/3
orthogonal_projection( x**2, cos(x), x, -pi, pi )
‚àí4cos(ùë•)
```
::: 

## Ortogonaliza√ß√£o de Gram-Schmidt


O processo de ortogonaliza√ß√£o  de Gram-Schmidt est√° descrita na demonstra√ß√£o do @thm-gram-sch. Vamos revisar o processo aqui rapidamente. Assuma que $v_1,\ldots,v_n$ √© um sistema L.I. em um espa√ßo vetorial $V$ com produto interno. Defina os vetores $w_1,\ldots,w_n$ da seguinte forma:
\begin{align*}
w_1&=v_1;\\
w_2&=v_2-\mbox{proj}_{w_1}(v_2);\\
w_3&=v_3-\mbox{proj}_{w_1}(v_3)-\mbox{proj}_{w_2}(v_3);\\
&\vdots\\
w_n&=v_n-\mbox{proj}_{w_1}(v_n)-\mbox{proj}_{w_2}(v_n)-\cdots-\mbox{proj}_{w_{n-1}}(v_n).
\end{align*}
Ent√£o o sistema $w_1,\ldots,w_n$ √© ortogonal e os subespa√ßos $\left<v_1,\ldots,v_i\right>$, $\left<w_1,\ldots,w_i\right>$ s√£o iguais para todo $i\in\{1,\ldots,n\}$. 


:::{#exr-gram-sch}
Escreva uma fun√ß√£o `gram_schmidt(funcs, var, a, b)` que, dada uma lista `funcs` de fun√ß√µes (assumindo que elas s√£o L.I.), aplica o processo de ortogonaliza√ß√£o de Gram-Schmidt para esta lista.  A sua fun√ß√£o deve verificar as seguintes computa√ß√µes. 
```python
gram_schmidt([1,x,x**2], x, -1, 1)
[1, x, x**2 - 1/3]
gram_schmidt([1,x,x**2], x, 0, 1)
[1, x - 1/2, x**2 - x + 1/6]
gram_schmidt([1,cos(x),sin(x)], x, -pi, pi)
[1, cos(x), sin(x)]
```
**Dica:** Cria uma lista `ws` para guardar as fun√ß√µes $w_1,\ldots,w_n$. Assumindo que as fun√ß√µes $w_1,\ldots,w_{k}$ foram calculadas e est√£o na lista `ws`, o pr√≥ximo elemento de `ws` pode ser calculado com 
```python
f - sum(orthogonal_projection(f, w, var, a, b) for w in ws)
```
onde `f` √© o elemento atual de `funcs`.
:::

:::{#exr-gram-sch1}
Usando a fun√ß√£o `gram_schmidt` no @exr-gram-sch, calcule uma base ortogonal para o espa√ßo $\R_4[x]$ considerando o produto interno 
na @eq-prod-int-int sobre o intervalo $[-1,1]$ e sobre o intervalo $[0,1]$. Verifique com a fun√ß√£o `inner_product` escrita no @exr-ip-int1 que as fun√ß√µes no output s√£o de fato ortogonais.
:::

## As s√©ries de Fourier

Para calcular as s√©ries de Fourier de algumas fun√ß√µes como no @thm-fourier, vamos primeiro aprender como calcular integrais numericamente. 

```python
integrate( cos(x)*sin(x), (x, -2, 1))
-sin^2(2)/2+sin(1)/2
integrate( cos(x)*sin(x), (x, -2, 1)).evalf()
‚àí0.0593741960791174
Integral(cos(x)*sin(x),(x,-2,1))
...integral object...
Integral( cos(x)*sin(x), (x, -2, 1)).evalf()
‚àí0.0593741960791174
```
Consulte o [manual](https://docs.sympy.org/latest/modules/evalf.html#sums-and-integrals) para mais informa√ß√µes.

:::{#exr-in-prod-num}
Modifique a sua implementa√ß√£o do produto interno e proje√ß√£o ortogonal no @exr-ip-int1 e no @exr-proj-ort tal que elas devolvam 
aproxima√ß√µes num√©ricas em vez de valores exatos. 
:::

:::{#exr-fourier}
Escreva uma fun√ß√£o em Python que dada uma fun√ß√£o $f\in C^\infty[a,b]$, calcula a aproxima√ß√£o de Fourier para a fun√ß√£o $f$ at√© grau $5$.A sua fun√ß√£o deve verificar as seguintes computa√ß√µes.
```python
fourier(x)
2.0sin(ùë•)‚àí1.0sin(2ùë•)+0.666666666666667sin(3ùë•)‚àí0.5sin(4ùë•)+0.4sin(5ùë•)
fourier(x**2)
‚àí4.0cos(ùë•)+1.0cos(2ùë•)‚àí0.444444444444444cos(3ùë•)+0.25cos(4ùë•)‚àí0.16cos(5ùë•)+3.28986813369645
fourier(abs(x))
‚àí1.27323954473516cos(ùë•)‚àí0.141471060526129cos(3ùë•)‚àí0.0509295817894065cos(5ùë•)+1.5707963267949
```
:::

:::{#exr-fourier}
Verifique visualmente a qualidade destas aproxima√ß√µes. Por exemplo 
```python
f = abs(x)
plot(f, xlim=(-3,3), ylim=(-1,4))
```
![abs(x)](img/abs.png)
```python
ff = fourier(f)
plot(ff, xlim=(-3,3), ylim=(-1,4))
```
![Fourier approximation of abs(x)](img/abs_four.png)

1. Fa√ßa a mesma coisa com outras fun√ß√µes, tais como $x$, $x^2$, $\exp(x)$, etc. 
2. Modifique a sua fun√ß√£o `fourier` tal que seja capaz de calcular as aproxima√ß√µes at√© grau $10$ ou at√© um grau $k$ arbitr√°rio fornecido pelo usu√°rio. 
3. Verifique se a qualidade das aproxima√ß√µes melhora assim que $k$ aumenta. 
:::